/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Obsidian2MuPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var path = __toESM(require("path"));
var DEFAULT_SETTINGS = {
  outputDir: "mu-output",
  autoConvert: false
};
var MuView = class extends import_obsidian.TextFileView {
  constructor(leaf) {
    super(leaf);
  }
  getViewType() {
    return "mu-view";
  }
  getDisplayText() {
    var _a;
    return ((_a = this.file) == null ? void 0 : _a.basename) || "Mu View";
  }
  async onOpen() {
  }
  async onClose() {
  }
  getViewData() {
    return this.data;
  }
  setViewData(data, clear) {
    this.data = data;
    const htmlContent = this.muToHtml(data);
    this.contentEl.innerHTML = `<div class="mu-content">${htmlContent}</div>`;
  }
  muToHtml(muContent) {
    return muContent.replace(/^>>>\s*(.*$)/gm, "<h3>$1</h3>").replace(/^>>\s*(.*$)/gm, "<h2>$1</h2>").replace(/^>\s*(.*$)/gm, "<h1>$1</h1>").replace(/`!(.*?)`!/g, "<strong>$1</strong>").replace(/`\*(.*?)`\*/g, "<em>$1</em>").replace(/`\[(.*?)`(.*?)\]/g, '<a href="$2">$1</a>').replace(/`=\n([\s\S]*?)\n`=/g, "<pre><code>$1</code></pre>").replace(/`=(.*?)`=/g, "<code>$1</code>").replace(/`_(.*?)`_/g, "<u>$1</u>").replace(/^-\s*(.*$)/gm, "<li>$1</li>").replace(/^>>>>(.*$)/gm, "<blockquote>$1</blockquote>").replace(/^-$/gm, "<hr>").replace(/^#\s*(.*$)/gm, "<!-- $1 -->");
  }
  clear() {
    this.data = "";
  }
};
var Obsidian2MuPlugin = class extends import_obsidian.Plugin {
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async convertToMu() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || !activeFile.extension.match(/md|markdown/)) {
      throw new Error("No markdown file is currently active");
    }
    await this.convertFile(activeFile);
  }
  async convertFile(file) {
    try {
      const content = await this.app.vault.read(file);
      const converted = this.markdownToMu(content);
      const outputPath = path.join(this.settings.outputDir, `${file.basename}.mu`);
      await this.ensureFolder(this.settings.outputDir);
      const existingFile = this.app.vault.getAbstractFileByPath(outputPath);
      if (existingFile instanceof import_obsidian.TFile) {
        await this.app.vault.modify(existingFile, converted);
      } else {
        await this.app.vault.create(outputPath, converted);
      }
      const muFile = this.app.vault.getAbstractFileByPath(outputPath);
      if (muFile instanceof import_obsidian.TFile) {
        this.app.workspace.getLeavesOfType("mu-view").forEach((leaf) => {
          if (leaf.view instanceof MuView && leaf.view.file === muFile) {
            leaf.view.setViewData(converted, false);
          }
        });
      }
    } catch (error) {
      console.error("Failed to convert file:", error);
      throw new Error(`Failed to convert ${file.basename}: ${error.message}`);
    }
  }
  markdownToMu(markdown) {
    return markdown.replace(/^####\s+(.*$)/gm, ">>>> $1").replace(/^###\s+(.*$)/gm, ">>> $1").replace(/^##\s+(.*$)/gm, ">> $1").replace(/^#\s+(.*$)/gm, "> $1").replace(/\*\*(.*?)\*\*/g, "`!$1`!").replace(/\*(.*?)\*/g, "`*$1`*").replace(/\[(.*?)\]\((.*?)\)/g, "`[$1`$2]").replace(/```(.*?)\n([\s\S]*?)```/g, "`=\n$2\n`=").replace(/`([^`]+)`/g, "`=$1`=").replace(/__(.*?)__/g, "`_$1`_").replace(/^\s*[-*+]\s/gm, "- ").replace(/^>\s*(.*$)/gm, ">>>>$1").replace(/^[-*_]{3,}\s*$/gm, "-").replace(/^#\s*(.*$)/gm, "# $1").replace(/^(>+.*$)/gm, "$1\n").replace(/\n{3,}/g, "\n\n").trim();
  }
  async ensureFolder(folderPath) {
    const abstractFile = this.app.vault.getAbstractFileByPath(folderPath);
    if (!abstractFile) {
      await this.app.vault.createFolder(folderPath);
    }
  }
  async onload() {
    console.log("Loading Obsidian2Mu Plugin");
    try {
      await this.loadSettings();
      this.registerExtensions(["mu"], "mu-view");
      this.registerView("mu-view", (leaf) => new MuView(leaf));
      this.addSettingTab(new Obsidian2MuSettingTab(this.app, this));
      this.addRibbonIcon("file-down", "Convert to .mu", async () => {
        try {
          await this.convertToMu();
          new import_obsidian.Notice("Conversion completed successfully");
        } catch (error) {
          console.error("Conversion failed:", error);
          new import_obsidian.Notice(`Conversion failed: ${error.message}`);
        }
      });
      if (this.settings.autoConvert) {
        let timeoutId;
        this.registerEvent(
          this.app.vault.on("modify", async (file) => {
            if (file.extension === "md" || file.extension === "markdown") {
              if (timeoutId)
                clearTimeout(timeoutId);
              timeoutId = setTimeout(async () => {
                try {
                  await this.convertFile(file);
                  const muPath = `${this.settings.outputDir}/${file.basename}.mu`;
                  const muFile = this.app.vault.getAbstractFileByPath(muPath);
                  if (muFile instanceof import_obsidian.TFile) {
                    const muContent = await this.app.vault.read(muFile);
                    for (const leaf of this.app.workspace.getLeavesOfType("mu-view")) {
                      if (leaf.view instanceof MuView && leaf.view.file === muFile) {
                        leaf.view.setViewData(muContent, false);
                      }
                    }
                  }
                } catch (error) {
                  console.error("Auto-conversion failed:", error);
                  new import_obsidian.Notice(`Auto-conversion failed: ${error.message}`);
                }
              }, 500);
            }
          })
        );
      }
    } catch (error) {
      console.error("Failed to load plugin:", error);
    }
  }
  async onunload() {
    console.log("Unloading Obsidian2Mu Plugin");
  }
};
var Obsidian2MuSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Output Directory").setDesc("Directory where .mu files will be saved").addText((text) => text.setPlaceholder("mu-output").setValue(this.plugin.settings.outputDir).onChange(async (value) => {
      this.plugin.settings.outputDir = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto Convert").setDesc("Automatically convert files when they are modified").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoConvert).onChange(async (value) => {
      this.plugin.settings.autoConvert = value;
      await this.plugin.saveSettings();
    }));
  }
};
